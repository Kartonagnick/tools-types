
[P]: ../../icons/progress.png
[V]: ../../icons/success.png
[X]: ../../icons/failed.png
[D]: ../../icons/danger.png
[E]: ../../icons/empty.png
[N]: ../../icons/na.png

[OLD]: variadic/variadic-old.md "версия для старых компиляторов"  
[NEW]: variadic/variadic-new.md "версия для новых компиляторов"  

version 0.0.2
---

[new-compilers][NEW][![V]][NEW]  
[old-compilers][OLD][![D]][OLD] [![X]][OLD] 

| **ID**  | 2019      | 20017     | 2015      | 2013      | 2012      | 2010      | 2008      |  
|:-------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|  
| msvc    | [![V]][M] | [![V]][M] | [![V]][M] | [![D]][0] | [![D]][0] | [![D]][0] | [![X]][0] |  

| **ID**  | 810       | 720       | 710       |  
|:-------:|:---------:|:---------:|:---------:|  
| mingw   | [![V]][M] | [![V]][M] | [![V]][M] |  

[M]: #variadic  "решение проблемы провалов в шаблоно-конструкторы"  
[0]: #variadic  "проблемы со старыми компиляторами"

variadic
---
Решает проблему провалов в шаблоно-конструкторы.  
Рассмотрим пример:  

```cpp
struct example
{
    template<typename... args>
    example(args&&...) {}
    example(const example&);
};

int main()
{
    example ex1;
    example ex2 = ex1;
}
```
Ожидается, что экземпляр `ex2` будет сконструирован конструктором копии.  
Однако, шаблонный конструктор подходит лучше, потому что не требует добавлять к типу квалификатор.  
Ситуация, когда вместо конструктора копии (или перемещения) 
запускается шаблоно-конструктор называется "провал в шаблоно-конструктор"  

Очевидное решение этой проблемы:  
Для указанного класса `U` нужно запретить инстанцировать шаблоно-конструктор,  
если оба условия будут выполнены:  
  - кол-во аргументов равно `1`  
  - тип `decay_t<T>` является `U` или его наследником  

## Пример использования

```cpp
#include <tools/types/variadic.hpp>
struct example
{
    template<typename... args, dTEMPLATE_CONSTRUCT(example, args...)>
    example(args&&...) { /* variadic arguments */ }
    
    template<typename arg, dTEMPLATE_CONSTRUCT(example, arg)>
    example(arg&&) { /* one template argument */ }

    example(const example&);
    example(example&&);
    example();        
};
```

Состав:  
  - is_heir  
    - Мета-функция возвращает true, если T - наследник U  
  - dTEMPLATE_CONSTRUCT  
    - Концепт: предотвращает провалы в шаблоно-конструкторы  
  - dTEMPLATE_CONSTRUCT_ARG  
    - Концепт старого образца:  
      - используется в параметрах функций при объявлении  
      - предотвращает провалы в шаблоно-конструкторы  
  - dTEMPLATE_CONSTRUCT_IMPL  
    - Концепт старого образца:  
      - используется в параметрах функций при определении  
      - предотвращает провалы в шаблоно-конструкторы  

Модуль представлен двумя реализациями:  
  - [variadic-old][OLD] - для старых компиляторов.  
    - есть противопоказания и ограничения [![D]][OLD] [![X]][OLD]  
  - [variadic-new][NEW] - для новых компиляторов.  

История изменений 
------

| **ID** |      tools      | types | версия |     дата      |  время   |  
|:------:|:---------------:|:-----:|:------:|:-------------:|:--------:|  
|  0001  | 0.2.7 [![P]][M] | 1.1.1 | 0.0.2  | 2021y-03m-26d | 08:26:36 |  
|  0000  | 0.2.7 [![P]][M] | 1.1.0 | 0.0.1  | 2021y-03m-25d | 21:31:43 |  

